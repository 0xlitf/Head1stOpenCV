<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="24.05.0.0">
<procedure name="generate_shape_model_dynamic">
<interface>
<io>
<par name="ImageModel" base_type="iconic" dimension="0"/>
<par name="RegionROI" base_type="iconic" dimension="0"/>
<par name="ModelRegions" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ModelRegionsOrigin" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ModelIDs" base_type="ctrl" dimension="0"/>
<par name="ModelWidthAll" base_type="ctrl" dimension="0"/>
<par name="ModelHeightAll" base_type="ctrl" dimension="0"/>
<par name="ModelGrays" base_type="ctrl" dimension="0"/>
<par name="Threshold" base_type="ctrl" dimension="0"/>
<par name="WdiffValue" base_type="ctrl" dimension="0"/>
<par name="IsDynamic" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="ModelWidth" base_type="ctrl" dimension="0"/>
<par name="ModelHeight" base_type="ctrl" dimension="0"/>
<par name="ModelArea" base_type="ctrl" dimension="0"/>
<par name="ModelGrayVal" base_type="ctrl" dimension="0"/>
<par name="isTrained" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>isTrained := 0</l>
<c></c>
<l>MinScore := 0.7</l>
<l>Score := []</l>
<l>ModelWidth := []</l>
<l>ModelHeight := []</l>
<l>isDefect := []</l>
<l>set_color(WindowHandle, 'green')</l>
<l>set_draw(WindowHandle, 'margin')</l>
<l>set_line_width(WindowHandle, 3)</l>
<l>* dev_set_color('green')</l>
<l>* boundary(RegionROI, RegionBorder, 'outer')</l>
<l>* dilation_circle(RegionBorder, RegionBorder, 2)</l>
<l>* paint_region(RegionBorder, ImageModel, ImageTemp, 255, 'fill')</l>
<l>get_image_size(ImageModel, imgWidth, imgHeight)</l>
<l>AreaMax := imgWidth*imgHeight</l>
<l>tmp_WdiffValue := 3 * imgWidth/320   </l>
<l>MinDefectInnerRadian := 3 * imgWidth/320   </l>
<l>MinDefectArea := 50 * imgWidth/320   </l>
<c></c>
<l>* reduce_domain(ImageModel, RegionROI, ImageReduced)</l>
<l>* threshold(ImageReduced, ModelRegionsOrigin, 0, Threshold)</l>
<l>* count_obj(ModelRegionsOrigin, ObjNum)</l>
<l>area_center(RegionROI, Area, CenterRow, CenterColumn)</l>
<l>smallest_rectangle1(RegionROI, ROILeftR, ROILeftC, ROIRightR, ROIRightC)</l>
<l>MaxToySize := (ROIRightR - ROILeftR) * 0.98</l>
<c></c>
<l>boundary(RegionROI, RegionBorder, 'outer')</l>
<l>search_shape_model_gray (ImageModel, RegionROI, ModelRegions, ModelRegionsOrigin, WindowHandle, ModelIDs, ModelGrays, Threshold, WdiffValue, MinScore, MinDefectInnerRadian, NewRow, NewColumn, NewWidth, NewArea, Model, isDefect)</l>
<c></c>
<c></c>
<c></c>
<c>*考虑到挨在一起的物料，以及杂料。</c>
<c>*未匹配到物料时，isDefect 物料数量可能大于模版数量 |Model|</c>
<c>*重复匹配时，则反过来</c>
<l>ObjNum := |isDefect|</l>
<l>disp_image(ImageModel, WindowHandle)</l>
<l>disp_region(RegionBorder, WindowHandle)</l>
<l>set_color(WindowHandle, 'magenta')</l>
<l>disp_region(ModelRegionsOrigin, WindowHandle)   </l>
<c></c>
<c>* 如果无料直接退出</c>
<l>if(ObjNum = 0)  </l>
<l>    return()</l>
<l>else</l>
<c></c>
<c>    *看最左边的料是否出边界，出的话 isTrained = 3 ，先计数</c>
<l>    tuple_min(NewColumn, Left)</l>
<l>    if(Left &lt; ROILeftC+ 15* imgWidth/320)</l>
<c>        * 如果出视野结果为3</c>
<l>        isTrained := 3</l>
<l>        return ()</l>
<l>    endif</l>
<c>        </c>
<c>    </c>
<c>    * 如果有多个料，分手动和自动两种模式</c>
<l>    gen_empty_obj(NewObj)</l>
<l>    gen_empty_obj(DetectedObj) </l>
<l>    gen_empty_obj(IO_Obj) </l>
<c>    * 手动模式下画面内不允许存在多个物料</c>
<l>    if(IsDynamic = 0) </l>
<l>        if(ObjNum = 1)</l>
<l>            concat_obj(NewObj, ModelRegionsOrigin, NewObj)</l>
<l>        else</l>
<l>            set_color(WindowHandle, 'red')</l>
<l>            disp_region(ModelRegionsOrigin, WindowHandle)</l>
<l>            disp_message(WindowHandle, '检测到多个物料！ ', 'window', -1, -1, 'red', 'true')</l>
<l>            return()</l>
<l>        endif</l>
<l>    else</l>
<l>        sort_region(ModelRegionsOrigin, ModelRegionsOrigin, 'upper_right', 'true', 'column')</l>
<l>        select_obj(ModelRegionsOrigin, ObjectSelected, 1)</l>
<l>        for j:= 0 to ObjNum-1 by 1</l>
<l>            if(NewColumn[j]=Left)</l>
<c>                * 只训练处理最左边那个</c>
<l>                if((isDefect[j] = 1)or(isDefect[j] = 3))</l>
<l>                    concat_obj(NewObj, ObjectSelected, NewObj)</l>
<l>                    break</l>
<l>                elseif(isDefect[j] = 2)</l>
<l>                    concat_obj(IO_Obj, ObjectSelected, IO_Obj)</l>
<l>                    isTrained := 0</l>
<l>                else</l>
<l>                    if(|Model|&gt;0)</l>
<l>                        ModelID := ModelIDs[Model[j]]</l>
<l>                    else</l>
<l>                        ModelID := 0</l>
<l>                    endif</l>
<l>                    concat_obj(DetectedObj, ObjectSelected, DetectedObj)</l>
<l>                    isTrained := 2</l>
<l>                endif</l>
<l>            endif</l>
<l>        endfor</l>
<l>        set_color(WindowHandle, 'orange')</l>
<l>        disp_region(IO_Obj, WindowHandle)</l>
<c>        * 如果都是训练过的，则不创建模版</c>
<l>        if(isTrained = 2)</l>
<l>            set_color(WindowHandle, 'magenta')</l>
<l>*             get_rgb(WindowHandle, Red, Green, Blue) </l>
<l>            disp_region(DetectedObj, WindowHandle)</l>
<l>            disp_message(WindowHandle, '检测到已训练物料ID：' + Model, 'window', -1, -1, 'magenta', 'true')</l>
<l>            return()</l>
<l>        endif</l>
<l>    endif</l>
<c></c>
<l>endif</l>
<c></c>
<c></c>
<l>area_center(NewObj, ModelArea, objRow, ObjColumn)</l>
<l>smallest_rectangle1(NewObj, Rect1RowL, Rect1ColL, Rect1RowR, Rect1ColR)</l>
<l>smallest_rectangle2(NewObj, Row1, Column1, Phi, ModelWidthHalf, ModelHeightHalf)</l>
<l>ModelWidth := ModelWidthHalf * 2</l>
<l>ModelHeight := ModelHeightHalf * 2</l>
<c></c>
<c>* 正在进入和出去视野的物料，一律视为杂料并忽略</c>
<l>if((Rect1ColL &gt; ROILeftC + 5) and (Rect1ColR &lt; ROIRightC - 5) and (ModelArea &gt; 30) and (ObjNum &gt; 0))    </l>
<l>    dilation_circle(NewObj, ModelRegionROI, 3)</l>
<l>    fill_up(ModelRegionROI, ModelRegionROI)</l>
<l>    reduce_domain(ImageModel, ModelRegionROI, ImageResult)</l>
<l>    intensity(NewObj, ImageResult, ModelGrayVal, Deviation)</l>
<l>    area_center(NewObj, Area, CenterRow, CenterColumn)</l>
<l>*     fill_up(NewObj, NewObj)</l>
<l>*     paint_region(NewObj, ImageResult, ImageResult, 0, 'fill')</l>
<c></c>
<c>    * step 2: create the model</c>
<l>    inspect_shape_model (ImageResult, ShapeModelImages, ShapeModelRegions, 15, 30)</l>
<c></c>
<l>*     dev_display (ShapeModelRegions)</l>
<l>    area_center (ShapeModelRegions, AreaModelRegions, RowModelRegions, ColumnModelRegions)</l>
<l>    count_obj (ShapeModelRegions, HeightPyramid)</l>
<l>    NumLevels := 0</l>
<l>    for i := 1 to HeightPyramid by 1</l>
<l>        if (AreaModelRegions[i - 1] &gt;= 15)</l>
<l>            NumLevels := i</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<l>    ScaleMin := 0.85</l>
<l>    ScaleMax := 1.15</l>
<l>    MinContrast := 30</l>
<l>*    create_scaled_shape_model(ImageResult, NumLevels, 0, rad(360), 'auto', ScaleMin, ScaleMax, 'auto', 'auto', 'ignore_local_polarity', 70, MinContrast, ModelID)</l>
<l>    create_shape_model (ImageResult, NumLevels, 0, rad(360), 'auto', 'auto', 'ignore_local_polarity', 70, MinContrast, ModelID)</l>
<l>*       create_shape_model (ImageResult, NumLevels, 0, rad(360), 'auto', 'point_reduction_high', 'use_polarity', 70, MinContrast, ModelID)</l>
<l>*       set_shape_model_origin(ModelID, -CenterRow, -CenterColumn)</l>
<l>      get_shape_model_params(ModelID, NumLevels1, AngleStart, AngleExtent, AngleStep, ScaleMin1, ScaleMax1, ScaleStep, Metric, MinContrast1)</l>
<l>    get_shape_model_contours (ModelContours, ModelID, 1)</l>
<l>    set_color(WindowHandle, 'green')</l>
<l>    disp_region(NewObj, WindowHandle)   </l>
<c>    </c>
<l>    union1(NewObj, ModelRegionsOrigin)</l>
<l>    disp_message(WindowHandle, '创建模版成功！ ', 'window', -1, -1, 'green', 'true')</l>
<l>    isTrained := 1</l>
<l>endif</l>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="generate_shape_model_dynamic">
<parameters>
<parameter id="ImageModel">
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="IsDynamic">
<default_value>0</default_value>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelArea">
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ModelGrayVal">
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelGrays">
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelHeight">
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ModelHeightAll">
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ModelID">
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelIDs">
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelRegions">
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="ModelRegionsOrigin">
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="ModelWidth">
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ModelWidthAll">
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RegionROI">
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Threshold">
<default_value>200</default_value>
<mixed_type>optional</mixed_type>
<multivalue>false</multivalue>
<sem_type>any</sem_type>
</parameter>
<parameter id="WdiffValue">
<default_value>3</default_value>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_value>3600</default_value>
<mixed_type>false</mixed_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>WindowHandle</item>
</values>
</parameter>
<parameter id="isTrained">
<mixed_type>false</mixed_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>1</value_max>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
